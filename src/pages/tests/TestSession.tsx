import { FC, useEffect, useState } from "react";
import {
  LoaderFunction,
  LoaderFunctionArgs,
  redirect,
  useLoaderData,
  useParams,
} from "react-router-dom";
import ButtonBox from "../../components/ButtonBox";
import axios, { AxiosError } from "axios";
import Clock from "../../components/Clock";
import QuestionComponent from "../../components/QuestionComponent";

interface TestSessionProps {}

const TestSession: FC<TestSessionProps> = ({}) => {
  //TODO: Fix type in efficient way
  const { testId } = useParams();
  const loaderData = useLoaderData() as any;
  const startTime = new Date(loaderData.startTime);
  //TODO: smarter way to deal with types
  const [questions, setQuestions] = useState<
    {
      hexId: string;
      markedForReview: boolean;
      seen: boolean;
      chosenOptionId: string | null;
    }[]
  >(loaderData.questions);

  console.log("questions = ", questions);
  const [chosenOptionId, setChosenOptionId] = useState<string | null>(null);
  const [activeQuestionId, setActiveQuestionId] = useState(questions[0].hexId);
  const [acitveQuestion, setActiveQuestion] = useState<{
    statement: string;
    type: "mcq" | "numerical";
    options?: { hexId: string; statement: string }[];
  }>({ statement: "", type: "mcq", options: [] });

  const activeQuestionIndex = questions.findIndex((q) => q.hexId === activeQuestionId);
  useEffect(() => {
    axios
      .get(`http://localhost:8080/api/tests/${testId}/questions/${activeQuestionId}`, {
        withCredentials: true,
      })
      .then((response) => {
        console.log("response = ", response);
        setActiveQuestion({
          statement: response.data.statement,
          options: response.data.options,
          type: response.data.questionType,
        });
      })
      .catch((err) => {
        console.log("err = ", err);
      });
    if (!questions[activeQuestionIndex].seen) {
      axios
        .put(
          `http://localhost:8080/api/tests/${testId}/questions/${activeQuestionId}`,
          {
            markedForReview: questions[activeQuestionIndex].markedForReview,
            chosenOptionId: questions[activeQuestionIndex].chosenOptionId,
          },
          { withCredentials: true }
        )
        .then((res) => {
          console.log("put res = ", res);
        });
    }
    setQuestions((prevQuestions) => {
      return prevQuestions.map((q) => {
        if (q.hexId === activeQuestionId) {
          return { ...q, seen: true };
        }
        return q;
      });
    });

    setChosenOptionId(questions[activeQuestionIndex].chosenOptionId);
  }, [activeQuestionId]);

  const reviewAndNextHandler = async () => {
    await axios.put(
      `http://localhost:8080/api/tests/${testId}/questions/${activeQuestionId}`,
      {
        markedForReview: true,
        chosenOptionId: chosenOptionId,
      },
      { withCredentials: true }
    );

    setQuestions((prevQuestions) => {
      return prevQuestions.map((q) => {
        if (q.hexId === activeQuestionId) {
          const markedForReview = q.markedForReview;
          return { ...q, chosenOptionId: chosenOptionId, markedForReview: !markedForReview };
        }
        return q;
      });
    });
    if (activeQuestionIndex + 1 < questions.length) {
      setActiveQuestionId(questions[activeQuestionIndex + 1].hexId);
    }
  };
  const nextHandler = async () => {
    const activeQuestionIndex = questions.findIndex((q) => q.hexId === activeQuestionId);
    await axios.put(
      `http://localhost:8080/api/tests/${testId}/questions/${activeQuestionId}`,
      {
        markedForReview: questions[activeQuestionIndex].markedForReview,
        chosenOptionId: chosenOptionId,
      },
      { withCredentials: true }
    );
    setQuestions((prevQuestions) => {
      return prevQuestions.map((q) => {
        if (q.hexId === activeQuestionId) {
          return { ...q, chosenOptionId: chosenOptionId };
        }
        return q;
      });
    });
    if (activeQuestionIndex + 1 < questions.length) {
      setActiveQuestionId(questions[activeQuestionIndex + 1].hexId);
    }
  };
  return (
    <>
      <div className="h-screen w-screen bg-[#202020] text-[#e2e2e2]">
        <Clock startDate={startTime} />
        <div className="flex flex-col h-[85%]">
          <div className="flex justify-between flex-grow">
            <div className="flex flex-col w-full h-full justify-between pr-12">
              <QuestionComponent
                chosenOptionId={chosenOptionId}
                setChosenOptionId={setChosenOptionId}
                question={acitveQuestion.statement}
                options={acitveQuestion.options!}
              />
              <div className="flex justify-between">
                <button
                  className="ml-9 bg-[#c75c54] hover:bg-[#de4c4a]  py-2 px-4 rounded-lg"
                  onClick={reviewAndNextHandler}
                >
                  {questions[activeQuestionIndex].markedForReview ? "Unmark from" : "Mark for"}{" "}
                  review and next
                </button>
                <div className="flex justify-center gap-4">
                  <button className=" bg-[#c75c54] hover:bg-[#de4c4a] py-2 px-4 rounded-lg">
                    Submit
                  </button>
                  <button
                    className=" bg-[#c75c54] hover:bg-[#de4c4a] py-2 px-4 rounded-lg"
                    onClick={nextHandler}
                  >
                    Next
                  </button>
                </div>
              </div>
            </div>
            <ButtonBox
              activeQuestionId={activeQuestionId}
              setActiveQuestionId={setActiveQuestionId}
              questions={questions}
            />
          </div>
        </div>
      </div>
    </>
  );
};

export default TestSession;

export const TestSessionLoader: LoaderFunction = async (args: LoaderFunctionArgs) => {
  /**
   * validate if session exists.
   *    1. [done] extract params.testId.
   *    2. [done] Send request to backend. Backend must validate if user.ongoingTestSession is of this test.
   *    3. [done] Backend must automatically destroy the session once timer runs out or submit test has been clicked.
   * If Yes:
   *    1. A lot of information has to be pulled. Not sure how to proceed, and whether to proceed in parts.
   *    2. For now questions will be pulled with following fields {subject, type, hexId}
   *    3. A list of buttons is created, under respective subject.
   *        i. On button click question information is pulled from backend.
   *            a. Backend must validate if question belongs to test. And if the test session exists.
   *        ii. Display the information accordingly.
   */
  console.log("inside TestSession.tsx loader");
  // return redirect("/")
  const testId = args.params.testId;
  try {
    const response = await axios.get(`http://localhost:8080/api/tests/${testId}/status`, {
      withCredentials: true,
    });
    console.log("loader response = ", response);
    if (response.status === 200) {
      return {
        startTime: response.data.startTime,
        questions: response.data.questions,
      };
    }
  } catch (err: any) {
    if (!(err instanceof AxiosError)) {
      //I am only epxecting AxiosError in this catch statement
      throw err;
    }
    if (err.response?.status === 401) {
      console.log("Unauthorized request was made. You are being redirected to home page");
      return redirect("/");
    }
  }

  // axios
  //   .get(`http://localhost:8080/api/tests/${testId}/status`, {
  //     withCredentials: true,
  //   })
  //   .then((response) => {
  //     console.log("response = ", response);
  //     if (response.status === 200) {
  //       const startTime = response.data.startTime;
  //       return {
  //         startTime,
  //       };
  //     }
  //   })
  //   .catch((err) => {
  //     if (err.response.status === 401) {
  //       console.log("Unauthorized request was made. You are being redirected to home page");
  //       return redirect("/");
  //     }
  //   }).finally(() => {
  //     redirect("/")
  //   });
  return null;
};
